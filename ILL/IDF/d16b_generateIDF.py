import os
import sys
from math import asin, pi, sin, cos
from lxml import etree as le
import numpy as np

path = os.path.abspath("")
sys.path.insert(0, path)
from helper import MantidGeom

# unit is metre
instrumentName = 'D16B'
validFrom = "2022-12-01 00:00:00"

monochromator_source = -2.8

# 2 monitors
zMon1 = -1  # TOF distance is not relevant for D16B, so an arbitrary value should be fine here for now.

# definition of the quadratic detector
numberPixelsPerWire = 192
numberWires = 1152

radius = 1.150

# definition of a quadratic pixel
pixelName = "pixel"
pixelWidth = 0.0015
pixelHeight = 0.002
x = pixelWidth / 2.
y = pixelHeight / 2.
z = 0.

# introductory comment
comment = """
       This is the instrument definition file of the D16 high-resolution diffractometer, in his most recent geometry.
       Generated file, PLEASE DO NOT EDIT THIS FILE!
       This file was automatically generated by mantidgeometry/ILL/IDF/d16b_generateIDF.py
       It has to be launched from mantidgeometry main directory.

       z axis defines the direction of the beam
       y axis will be the axis used for rotation
       coordinate system is right-handed

       y axis rotation defined by theta
       x axis rotation defined by phi
       z axis rotation defined by chi

       width x direction, height y direction

       One detector
       Distance to sample: 1.15m
       Curvature: 1.15m
       Rotation: -5 < 2*theta < 125
       Pixel size: 1.5mm (width) x 2mm (height) ( 1152 x 192 pixels )

       For more information, please visit
       https://www.ill.eu/instruments-support/instruments-groups/instruments/d16/characteristics/
       """


# Instrument creation
d16 = MantidGeom(instrumentName, comment=comment, valid_from=validFrom)
d16.addSnsDefaults(default_view='CYLINDRICAL_Y')

d16.addComment("SOURCE")
d16.addComponentILL("monochromator", 0., 0., monochromator_source, "Source")

# Sample is set as the origin
d16.addComment("Sample position")
d16.addComponentILL("sample_position", 0., 0., 0., "SamplePos")

# Place 2 monitors
d16.addComment("MONITORS")
d16.addMonitors(names=["monitor1"], distance=[zMon1])
d16.addComment("MONITOR SHAPE")
d16.addDummyMonitor(0.01, 0.01)
d16.addComment("MONITOR IDs")
d16.addMonitorIds([repr(500000)])

# Place the detectors
d16.addComment("DETECTORS")
theta = 2 * asin(pixelWidth / (2 * radius)) # the angular distance between 2 wires

# define a cylindrical pixel object
d16.addCylinderPixelAdvanced(
    pixelName, center_bottom_base={'x': 0., 'y': -pixelHeight / 2., 'z': 0.},
    axis={'x': 0., 'y': 1., 'z': 0.}, pixel_radius=pixelWidth / 2,
    pixel_height=pixelHeight,
    algebra='pixel_shape')

root = d16.getRoot()
detectorType = le.SubElement(root, 'type', name='detector')
wires = le.SubElement(detectorType, 'component', type='wire')

# place the wires
for i in range(numberWires):
    wireAngle = (numberWires // 2 - i) * theta
    x = radius * sin(wireAngle)
    z = radius * cos(wireAngle)
    attributes = {
        'x': str(x),
        'y': str(0.),
        'z': str(z),
        'name': 'wire_{}'.format(i + 1)
    }
    le.SubElement(wires, 'location', **attributes)

# define wires
wireType = le.SubElement(root, 'type', name='wire', outline='yes')
wire = le.SubElement(wireType, 'component', type=pixelName)

wire_bottom_pos = -(numberPixelsPerWire // 2) * pixelHeight
wire_top_pos = (numberPixelsPerWire // 2) * pixelHeight
pixelPositions = np.linspace(wire_bottom_pos, wire_top_pos, numberPixelsPerWire)

# define a wire by describing pixel positions
for i, pos in enumerate(pixelPositions):
    le.SubElement(wire, 'location', y=str(pos), name='pixel_{}'.format(i + 1))

detector = d16.addComponent('detector', idlist='detectors')
le.SubElement(detector, 'location')
d16.addDetectorIds('detectors', [1, numberPixelsPerWire * numberWires, None])

d16.writeGeom("./ILL/IDF/" + instrumentName + "_Definition.xml")
